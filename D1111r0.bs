<pre class='metadata'>
Title: Proposed Resolution to NB Comments on the Parallelism TS v2
Shortname: D1111
Revision: 0
Status: D
Audience: SG1, LEWG, LWG
Group: WG21
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p1111_proposed_resolution_to_nb_comments_on_the_parallelism_ts_v2/issues
URL: http://wg21.link/D1111R0
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Matthias Kretz, m.kretz@gsi.de
Date: 2018-06-04
Markup Shorthands: markdown yes
Toggle Diffs: yes
No Abstract: yes
</pre>

<style>
pre.highlight:not(.idl) { background: #ffffff; }
code.highlight:not(.idl) { background: #ffffff; }
ins, ins span { background: rgb(200, 250, 200); }
del, del span { background: rgb(250, 200, 200); }
</style>

All wording is relative to ISO/IEC PTDS 19750 ([[N4744]]), the PTDS for version
2 of the C++ Parallelism Technical Specification.

CA 3 {#ca3}
===========

Remove the column titled "Doc. No." from [**parallel.general.features**] Table 1.

CA 4 {#ca4}
===========

Modify [**parallel.alg.reductions**] Paragraph 3 as follows:

<blockquote>
Modifications to the accumulator by the application of element access functions accrue as
partial results.
At some point before the algorithm returns, the partial results are combined, two at a time, using the reduction object's combiner operation until a single value remains, which is then assigned back to the live-out object.
[ *Note:*
<del>in</del><ins>In</ins> order to produce useful results, modifications to the accumulator should be limited to commutative operations closely related to the combiner operation.
For example if the combiner is `plus<T>`, incrementing the accumulator would be consistent with the combiner but doubling it or assigning to it would not.
— *end note* ]
</blockquote>

CA 7, 8, 10, US 5, 6, CH 8 {#ca7}
==============================

<ul>
<li>Replace all occurences of "&#8714;" with "&#x2208;".</li>
<li>Replace all occurences of <del>&#8469;<sub>0</sub></del> with <ins>&#8469;</ins>.</li>
<li>Change the font of all occurences of "<del><code>[0, size())</code></del>" to "<ins>[0, <code>size()</code>)<ins>".</li>
<li>Replace all occurences of "<del>-th</del>" to "<ins><sup>th</sup></ins>".</li>
<li>Use math font for variables that are only used in prose. Use code font for variables that are used in code at least once.</li>
</ul>

<!--
Modify [**parallel.simd.whereexpr**] p5 as follows:
<blockquote>
The <em>selected indices</em> signify the integers <del><code>i</code> &#8714; {<em>j</em> &#8714; &#8469;<sub>0</sub> &#8739; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[</code><em>j</em><code>]</code> }.</del>
<ins><em>i</em> &#x2208; {<em>j</em> &#x2208; &#8469; &#x2223; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[j]</code> }.</ins>
The <em>selected elements</em> signify the elements <code>data[i]</code> for all selected indices <code>i</code>.
</blockquote>
-->

Modify [**parallel.simd.whereexpr**] p12 as follows:
<blockquote>
If the template parameter <code>Flags</code> is <code>vector_aligned_tag</code>, <code>mem</code> shall point to storage aligned by <code>memory_alignment_v&lt;T, U&gt;</code>.
If the template parameter <code>Flags</code> is <code>overaligned_tag&lt;N&gt;</code>, <code>mem</code> shall point to storage aligned by <code>N</code>.
If the template parameter <code>Flags</code> is <code>element_aligned_tag</code>, <code>mem</code> shall point to storage aligned by <code>alignof(U)</code>.
If <code>M</code> is not <code>bool</code>, the largest <del><code>i</code> &#8714; <code>[0, M::size())</code> where <code>mask[i]</code> is <code>true</code></del><ins>selected index</ins> is less than the number of values pointed to by <code>mem</code>.
</blockquote>

<!--
Modify [**parallel.simd.ctor**] p6 as follows:
<blockquote>
Constructs an object where the <del><em>i</em>-th</del><ins><code>i</code><sup>th</sup></ins>
element equals <code>static_cast&lt;T&gt;(x[i])</code> for all <code>i</code>
<del>&#8714; <code>[0, size())</code></del><ins>&#x2208; [0, <code>size()</code>)</ins>.
</blockquote>

Modify [**parallel.simd.ctor**] p9 as follows:
<blockquote>
Constructs an object where the <del><em>i</em>-th</del><ins><code>i</code><sup>th</sup></ins> element is initialized to <code>gen(integral_constant&lt;size_t, i&gt;())</code>.
</blockquote>

Modify [**parallel.simd.ctor**] p10 as follows:
<blockquote>
This constructor shall not participate in overload resolution unless <code>simd(gen(integral_constant&lt;size_t, i&gt;()))</code> is well-formed for all <code>i</code>
<del>&#8714; <code>[0, size())</code></del>
<ins>&#x2208; [0, <code>size()</code>)<ins>.
</blockquote>
-->

In [**parallel.simd.reductions**] replace all occurences of "for all <del><code>i</code> &#8714; {<em>j</em> &#8714; &#8469;<sub>0</sub> &#8739; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[</code><em>j</em><code>]</code> }</del>" with
"for all <ins>selected elements <code>i</code></ins>".

US 1, 2 {#us1}
===========

Modify [**parallel.simd.binary**] as follows:

<blockquote>
<xmp>
friend simd operator+(const simd& lhs, const simd& rhs);
friend simd operator-(const simd& lhs, const simd& rhs);
friend simd operator*(const simd& lhs, const simd& rhs);
friend simd operator/(const simd& lhs, const simd& rhs);
friend simd operator%(const simd& lhs, const simd& rhs);
friend simd operator&(const simd& lhs, const simd& rhs);
friend simd operator|(const simd& lhs, const simd& rhs);
friend simd operator^(const simd& lhs, const simd& rhs);
friend simd operator<<(const simd& lhs, const simd& rhs);
friend simd operator>>(const simd& lhs, const simd& rhs);
</xmp>

*Returns:* A `simd` object initialized with the results <del>of the element-wise application of the indicated operator.</del> <ins>applying the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins>

*Throws:* Nothing.

*Remarks:* Each of these operators shall not participate in overload resolution unless the
indicated operator can be applied to objects of type value_type .
</blockquote>

Modify [**parallel.simd.cassign**] as follows:

<blockquote>
<xmp>
friend simd& operator+=(simd& lhs, const simd& rhs);
friend simd& operator-=(simd& lhs, const simd& rhs);
friend simd& operator*=(simd& lhs, const simd& rhs);
friend simd& operator/=(simd& lhs, const simd& rhs);
friend simd& operator%=(simd& lhs, const simd& rhs);
friend simd& operator&=(simd& lhs, const simd& rhs);
friend simd& operator|=(simd& lhs, const simd& rhs);
friend simd& operator^=(simd& lhs, const simd& rhs);
friend simd& operator<<=(simd& lhs, const simd& rhs);
friend simd& operator>>=(simd& lhs, const simd& rhs);
friend simd& operator<<=(simd& lhs, int n);
friend simd& operator>>=(simd& lhs, int n);
</xmp>

*Effects:* These operators <del>perform the indicated binary element-wise operation.</del> <ins>apply the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins> 

*Returns:* `lhs`.

*Throws:* Nothing.

*Remarks:* These operators shall not participate in overload resolution unless the indicated operator can be applied to objects of type `value_type`.
</blockquote>

Modify [**parallel.simd.comparison**] as follows:

<blockquote>
<code><pre>
friend mask_type operator==(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator!=(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;gt;=(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;lt;=(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;gt;(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;lt;(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
</pre></code>

*Returns:* A `simd_mask` object initialized with the results of the <del>element-wise application of the indicated operator.</del> <ins>applying the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins> 

*Throws:* Nothing.
</blockquote>

Modify [**parallel.simd.mask.binary**] as follows:

<blockquote>
<code><pre>
friend simd_mask operator&amp;&amp;(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator||(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator&amp; (const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator| (const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator^ (const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
</pre></code>

*Returns:* A simd_mask object initialized with the results of the element-wise appliation of the indicated operator.
</blockquote>

Modify [**parallel.simd.mask.cassign**] as follows:

<blockquote>
<xmp>
friend simd_mask& operator&=(simd_mask& lhs, const simd_mask& rhs) noexcept;
friend simd_mask& operator|=(simd_mask& lhs, const simd_mask& rhs) noexcept;
friend simd_mask& operator^=(simd_mask& lhs, const simd_mask& rhs) noexcept;
</xmp>

*Effects:* These operators <del>perform the indicated binary element-wise operation.</del> <ins>apply the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins> 

*Returns:* `lhs`.
</blockquote>

Modify [**parallel.simd.mask.comparison**] as follows:

<blockquote>
<code><pre>
friend simd_mask operator==(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator!=(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
</pre></code>

*Returns:* An object initialized with the results of the <del>element-wise application of the indicated operator.</del> <ins>applying the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins>
</blockquote>

CH 12 {#ch12}
=============

After [**parallel.simd.whereexpr**] p17 and p20 add:
<blockquote>
<ins>
  <em>Throws:</em>
  Any exception thrown while converting <code>x</code> to <code>T</code>.
</ins>
</blockquote>

After [**parallel.simd.whereexpr**] p23 and p27 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.reference**] p6 and p10 add:
<blockquote>
<ins>
  <em>Throws:</em>
  Any exception thrown while converting <code>x</code> to <code>value_type</code>.
</ins>
</blockquote>

After [**parallel.simd.reference**] p14 and p18 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.ctor**] p6, p9, and p14 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

Modify [**parallel.simd.ctor**] p11 as follows:
<blockquote>
The calls to <code>gen</code> are unsequenced with respect to each other.
Vectorization-unsafe standard library functions may not be invoked by <code>gen</code> ([algorithms.parallel.exec]).
<ins>An invocation of <code>gen</code> shall not exit via an uncaught exception.</ins>
</blockquote>

After [**parallel.simd.copy**] p3 and p7 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.casts**] p22, p25, and p28 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

Modify [**parallel.simd.alg**] p7 as follows:
<blockquote>
<pre><code>
template&lt;class T, class Abi&gt; simd&lt;T, Abi&gt;
clamp(const simd&lt;T, Abi&gt;& v, const simd&lt;T, Abi&gt;& lo, const simd&lt;T, Abi&gt;& hi)<ins> noexcept</ins>;
</code></pre>
</blockquote>

After [**parallel.simd.mask.ctor**] p8 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.mask.copy**] p3 and p7 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.mask.reductions**] p13 and p16 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>


CH 13 {#ch13}
=============

NOTE: We should put other simd class synopsis updates in this diff.

Modify [**parallel.simd.overview**] as follows:

<blockquote>
<pre><code>
template&lt;class T, class Abi&gt; class simd {
public:
  using value_type = T;
  using reference = <i>see below</i>;
  using mask_type = simd_mask&lt;T, Abi&gt;<ins>;</ins>
  using abi_type = Abi;

  static constexpr size_t size() noexcept;

  simd() = default;

  <i>// implicit conversion constructor</i>
  template&lt;class U&gt; simd(const simd&lt;U, simd_abi::fixed_size&lt;size()&gt;&gt;&amp;);

  <i>// implicit broadcast constructor (see below for constraints)</i>
  template&lt;class U&gt; simd(U&amp;&amp; value);

  <i>// generator constructor (see below for constraints)</i>
  template&lt;class G&gt; explicit simd(G&amp;&amp; gen);

  <i>// load constructor</i>
  template&lt;class U, class Flags&gt; simd(const U* mem, Flags f);

  <i>// 9.3.4, Copy functions</i>
  template&lt;class U, class Flags&gt; copy_from(const U* mem, Flags f);
  template&lt;class U, class Flags&gt; copy_to(U* mem, Flags f);

  <i>// 9.3.5, Subscript operators</i>
  reference operator[](size_t);
  value_type operator[](size_t) const;

  <i>// 9.3.6, Unary operators</i>
  simd&amp; operator++();
  simd operator++(int);
  simd&amp; operator--();
  simd operator--(int);
  mask_type operator!() const;
  simd operator~() const;
  simd operator+() const;
  simd operator-() const;

  <i>// 9.4.1, Binary operators</i>
  friend simd operator+(const simd&amp;, const simd&amp;);
  friend simd operator-(const simd&amp;, const simd&amp;);
  friend simd operator*(const simd&amp;, const simd&amp;);
  friend simd operator/(const simd&amp;, const simd&amp;);
  friend simd operator%(const simd&amp;, const simd&amp;);
  friend simd operator&amp;(const simd&amp;, const simd&amp;);
  friend simd operator|(const simd&amp;, const simd&amp;);
  friend simd operator^(const simd&amp;, const simd&amp;);
  friend simd operator&lt;&lt;(const simd&amp;, const simd&amp;);
  friend simd operator&gt;&gt;(const simd&amp;, const simd&amp;);
  friend simd operator&lt;&lt;(const simd&amp;, int);
  friend simd operator&gt;&gt;(const simd&amp;, int);

  <i>// 9.4.2, Compound assignment</i>
  friend simd&amp; operator+=(simd&amp;, const simd&amp;);
  friend simd&amp; operator-=(simd&amp;, const simd&amp;);
  friend simd&amp; operator*=(simd&amp;, const simd&amp;);
  friend simd&amp; operator/=(simd&amp;, const simd&amp;);
  friend simd&amp; operator%=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&amp;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator|=(simd&amp;, const simd&amp;);
  friend simd&amp; operator^=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&lt;&lt;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&gt;&gt;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&lt;&lt;=(simd&amp;, int);
  friend simd&amp; operator&gt;&gt;=(simd&amp;, int);

  <i>// 9.4.3, Compare operators</i>
  friend mask_type operator==(const simd&amp;, const simd&amp;);
  friend mask_type operator!=(const simd&amp;, const simd&amp;);
  friend mask_type operator&gt;=(const simd&amp;, const simd&amp;);
  friend mask_type operator&lt;=(const simd&amp;, const simd&amp;);
  friend mask_type operator&gt;(const simd&amp;, const simd&amp;);
  friend mask_type operator&lt;(const simd&amp;, const simd&amp;);
};
</code></pre>
</blockquote>

CH 15 {#ch15}
=============

Modify the definition of `static_simd_cast` in [**parallel.simd.casts**] as follows:

<blockquote>
<pre><code>
template&lt;class T, class U, class Abi&gt; <i>see below</i> static_simd_cast(const simd&lt;U, Abi&gt;&amp; x);
</code></pre>

Let `To` identify `T::value_type` if `is_simd_v<T>` is true or `T` otherwise.

*Returns:* A simd object with the i-th element initialized to `static_cast<To>(x[i])` for all `i` &#x2208; `[0, size())`.

*Throws:* Nothing.

*Remarks:* The function shall not participate in overload resolution unless either
— `is_simd_v<T>` is `false`, or
— `T::size() == simd<U, Abi>::size()` is `true`.

The return type is
— T if `is_simd_v<T>` is `true`, otherwise
— `simd<T, Abi>` if either `U` is `T` or <del>`U` and `T` are integral types that only differ in signedness</del> <ins>`make_signed_t<U>` is `make_signed_t<T>`</ins>, otherwise
— `simd<T, simd_abi::fixed_size<simd<U, Abi>::size()>>`.
</blockquote>

