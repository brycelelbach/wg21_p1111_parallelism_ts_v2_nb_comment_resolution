<pre class='metadata'>
Title: Proposed Resolution to NB Comments on the Parallelism TS v2
Shortname: D1111
Revision: 0
Status: D
Audience: SG1, LEWG, LWG
Group: WG21
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p1111_proposed_resolution_to_nb_comments_on_the_parallelism_ts_v2/issues
URL: http://wg21.link/D1111R0
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Matthias Kretz, m.kretz@gsi.de
Date: 2018-06-04
Markup Shorthands: markdown yes
Toggle Diffs: yes
No Abstract: yes
</pre>

<style>
pre.highlight:not(.idl) { background: #ffffff; }
code.highlight:not(.idl) { background: #ffffff; }
ins, ins span { background: rgb(200, 250, 200); }
del, del span { background: rgb(250, 200, 200); }
</style>

All wording is relative to ISO/IEC PTDS 19750 ([[N4744]]), the PTDS for version
2 of the C++ Parallelism Technical Specification.

CA 4 {#ca4}
===========

Modify [**parallel.alg.reductions**] p3 as follows:

<blockquote>
Modifications to the accumulator by the application of element access functions accrue as
partial results.
At some point before the algorithm returns, the partial results are combined, two at a time, using the reduction object's combiner operation until a single value remains, which is then assigned back to the live-out object.
[ *Note:*
<del>in</del><ins>In</ins> order to produce useful results, modifications to the accumulator should be limited to commutative operations closely related to the combiner operation.
For example if the combiner is `plus<T>`, incrementing the accumulator would be consistent with the combiner but doubling it or assigning to it would not.
â€” *end note* ]
</blockquote>

CA 7, 8, 10, US 5, 6, CH 8 {#ca7}
==============================

<ul>
<li>Replace all occurences of "&#8714;" with "&#x2208;".</li>
<li>Replace all occurences of <del>&#8469;<sub>0</sub></del> with <ins>&#8469;</ins>.</li>
<li>Change the font of all occurences of "<del><code>[0, size())</code></del>" to "<ins>[0, <code>size()</code>)<ins>".</li>
<li>Replace all occurences of "<del>-th</del>" to "<ins><sup>th</sup></ins>".</li>
<li>Use math font for variables that are only used in prose. Use code font for variables that are used in code at least once.</li>
</ul>

<!--
Modify [**parallel.simd.whereexpr**] p5 as follows:
<blockquote>
The <em>selected indices</em> signify the integers <del><code>i</code> &#8714; {<em>j</em> &#8714; &#8469;<sub>0</sub> &#8739; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[</code><em>j</em><code>]</code> }.</del>
<ins><em>i</em> &#x2208; {<em>j</em> &#x2208; &#8469; &#x2223; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[j]</code> }.</ins>
The <em>selected elements</em> signify the elements <code>data[i]</code> for all selected indices <code>i</code>.
</blockquote>
-->

Modify [**parallel.simd.whereexpr**] p12 as follows:
<blockquote>
If the template parameter <code>Flags</code> is <code>vector_aligned_tag</code>, <code>mem</code> shall point to storage aligned by <code>memory_alignment_v&lt;T, U&gt;</code>.
If the template parameter <code>Flags</code> is <code>overaligned_tag&lt;N&gt;</code>, <code>mem</code> shall point to storage aligned by <code>N</code>.
If the template parameter <code>Flags</code> is <code>element_aligned_tag</code>, <code>mem</code> shall point to storage aligned by <code>alignof(U)</code>.
If <code>M</code> is not <code>bool</code>, the largest <del><code>i</code> &#8714; <code>[0, M::size())</code> where <code>mask[i]</code> is <code>true</code></del><ins>selected index</ins> is less than the number of values pointed to by <code>mem</code>.
</blockquote>

<!--
Modify [**parallel.simd.ctor**] p6 as follows:
<blockquote>
Constructs an object where the <del><em>i</em>-th</del><ins><code>i</code><sup>th</sup></ins>
element equals <code>static_cast&lt;T&gt;(x[i])</code> for all <code>i</code>
<del>&#8714; <code>[0, size())</code></del><ins>&#x2208; [0, <code>size()</code>)</ins>.
</blockquote>

Modify [**parallel.simd.ctor**] p9 as follows:
<blockquote>
Constructs an object where the <del><em>i</em>-th</del><ins><code>i</code><sup>th</sup></ins> element is initialized to <code>gen(integral_constant&lt;size_t, i&gt;())</code>.
</blockquote>

Modify [**parallel.simd.ctor**] p10 as follows:
<blockquote>
This constructor shall not participate in overload resolution unless <code>simd(gen(integral_constant&lt;size_t, i&gt;()))</code> is well-formed for all <code>i</code>
<del>&#8714; <code>[0, size())</code></del>
<ins>&#x2208; [0, <code>size()</code>)<ins>.
</blockquote>
-->

In [**parallel.simd.reductions**] replace all occurences of "for all <del><code>i</code> &#8714; {<em>j</em> &#8714; &#8469;<sub>0</sub> &#8739; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[</code><em>j</em><code>]</code> }</del>" with
"for all <ins>selected elements <code>i</code></ins>".


CH 13 {#ch13}
=============

NOTE: We should put other simd class synopsis updates in this diff.

Modify [**parallel.simd.overview**] as follows:

<blockquote>
<pre><code>
template&lt;class T, class Abi&gt; class simd {
public:
  using value_type = T;
  using reference = <i>see below</i>;
  using mask_type = simd_mask&lt;T, Abi&gt;<ins>;</ins>
  using abi_type = Abi;

  static constexpr size_t size() noexcept;

  simd() = default;

  <i>// implicit conversion constructor</i>
  template&lt;class U&gt; simd(const simd&lt;U, simd_abi::fixed_size&lt;size()&gt;&gt;&amp;);

  <i>// implicit broadcast constructor (see below for constraints)</i>
  template&lt;class U&gt; simd(U&amp;&amp; value);

  <i>// generator constructor (see below for constraints)</i>
  template&lt;class G&gt; explicit simd(G&amp;&amp; gen);

  <i>// load constructor</i>
  template&lt;class U, class Flags&gt; simd(const U* mem, Flags f);

  <i>// 9.3.4, Copy functions</i>
  template&lt;class U, class Flags&gt; copy_from(const U* mem, Flags f);
  template&lt;class U, class Flags&gt; copy_to(U* mem, Flags f);

  <i>// 9.3.5, Subscript operators</i>
  reference operator[](size_t);
  value_type operator[](size_t) const;

  <i>// 9.3.6, Unary operators</i>
  simd&amp; operator++();
  simd operator++(int);
  simd&amp; operator--();
  simd operator--(int);
  mask_type operator!() const;
  simd operator~() const;
  simd operator+() const;
  simd operator-() const;

  <i>// 9.4.1, Binary operators</i>
  friend simd operator+(const simd&amp;, const simd&amp;);
  friend simd operator-(const simd&amp;, const simd&amp;);
  friend simd operator*(const simd&amp;, const simd&amp;);
  friend simd operator/(const simd&amp;, const simd&amp;);
  friend simd operator%(const simd&amp;, const simd&amp;);
  friend simd operator&amp;(const simd&amp;, const simd&amp;);
  friend simd operator|(const simd&amp;, const simd&amp;);
  friend simd operator^(const simd&amp;, const simd&amp;);
  friend simd operator&lt;&lt;(const simd&amp;, const simd&amp;);
  friend simd operator&gt;&gt;(const simd&amp;, const simd&amp;);
  friend simd operator&lt;&lt;(const simd&amp;, int);
  friend simd operator&gt;&gt;(const simd&amp;, int);

  <i>// 9.4.2, Compound assignment</i>
  friend simd&amp; operator+=(simd&amp;, const simd&amp;);
  friend simd&amp; operator-=(simd&amp;, const simd&amp;);
  friend simd&amp; operator*=(simd&amp;, const simd&amp;);
  friend simd&amp; operator/=(simd&amp;, const simd&amp;);
  friend simd&amp; operator%=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&amp;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator|=(simd&amp;, const simd&amp;);
  friend simd&amp; operator^=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&lt;&lt;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&gt;&gt;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&lt;&lt;=(simd&amp;, int);
  friend simd&amp; operator&gt;&gt;=(simd&amp;, int);

  <i>// 9.4.3, Compare operators</i>
  friend mask_type operator==(const simd&amp;, const simd&amp;);
  friend mask_type operator!=(const simd&amp;, const simd&amp;);
  friend mask_type operator&gt;=(const simd&amp;, const simd&amp;);
  friend mask_type operator&lt;=(const simd&amp;, const simd&amp;);
  friend mask_type operator&gt;(const simd&amp;, const simd&amp;);
  friend mask_type operator&lt;(const simd&amp;, const simd&amp;);
};
</code></pre>
</blockquote>

