<pre class='metadata'>
Title: Proposed Resolution to NB Comments on the Parallelism TS v2
Shortname: D1111
Revision: 0
Status: D
Audience: SG1, LEWG, LWG
Group: WG21
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p1111_proposed_resolution_to_nb_comments_on_the_parallelism_ts_v2/issues
URL: http://wg21.link/D1111R0
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Matthias Kretz, m.kretz@gsi.de
Date: 2018-06-04
Markup Shorthands: markdown yes
Toggle Diffs: yes
No Abstract: yes
</pre>

<style>
pre.highlight:not(.idl), pre.highlight:not(.idl) * { background-color: transparent; }
code.highlight:not(.idl), code.highlight:not(.idl) * { background-color: transparent; }
pre.highlight:not(.idl) ins { background-color: rgb(200, 250, 200); }
code.highlight:not(.idl) ins { background-color: rgb(200, 250, 200); }
ins, ins * { background-color: rgb(200, 250, 200); }
del, del * { background-color: rgb(250, 200, 200); }
</style>

NOTE: All wording is relative to ISO/IEC PTDS 19750 ([[N4744]]), the PTDS for
version 2 of the C++ Parallelism Technical Specification.

NOTE: The changes should be applied in order.

CA 7, 8, 10, US 5, 6, CH 8 {#ca7}
==============================

<ul>
<li>Replace all occurences of "&#8714;" with "&#x2208;".</li>
<li>Replace all occurences of <del>&#8469;<sub>0</sub></del> with <ins>&#8469;</ins>.</li>
<li>Change the font of all occurences of "<del><code>[0, size())</code></del>" to "<ins>[0, <code>size()</code>)<ins>".</li>
<li>Replace all occurences of "<del>-th</del>" to "<ins><sup>th</sup></ins>".</li>
<li>Use math font for variables that are only used in prose. Use code font for variables that are used in code at least once.</li>
</ul>

<!--
Modify [**parallel.simd.whereexpr**] p5 as follows:
<blockquote>
The <em>selected indices</em> signify the integers <del><code>i</code> &#8714; {<em>j</em> &#8714; &#8469;<sub>0</sub> &#8739; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[</code><em>j</em><code>]</code> }.</del>
<ins><em>i</em> &#x2208; {<em>j</em> &#x2208; &#8469; &#x2223; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[j]</code> }.</ins>
The <em>selected elements</em> signify the elements <code>data[i]</code> for all selected indices <code>i</code>.
</blockquote>
-->

Modify [**parallel.simd.whereexpr**] p12 as follows:
<blockquote>
If the template parameter <code>Flags</code> is <code>vector_aligned_tag</code>, <code>mem</code> shall point to storage aligned by <code>memory_alignment_v&lt;T, U&gt;</code>.
If the template parameter <code>Flags</code> is <code>overaligned_tag&lt;N&gt;</code>, <code>mem</code> shall point to storage aligned by <code>N</code>.
If the template parameter <code>Flags</code> is <code>element_aligned_tag</code>, <code>mem</code> shall point to storage aligned by <code>alignof(U)</code>.
If <code>M</code> is not <code>bool</code>, the largest <del><code>i</code> &#8714; <code>[0, M::size())</code> where <code>mask[i]</code> is <code>true</code></del><ins>selected index</ins> is less than the number of values pointed to by <code>mem</code>.
</blockquote>

<!--
Modify [**parallel.simd.ctor**] p6 as follows:
<blockquote>
Constructs an object where the <del><em>i</em>-th</del><ins><code>i</code><sup>th</sup></ins>
element equals <code>static_cast&lt;T&gt;(x[i])</code> for all <code>i</code>
<del>&#8714; <code>[0, size())</code></del><ins>&#x2208; [0, <code>size()</code>)</ins>.
</blockquote>

Modify [**parallel.simd.ctor**] p9 as follows:
<blockquote>
Constructs an object where the <del><em>i</em>-th</del><ins><code>i</code><sup>th</sup></ins> element is initialized to <code>gen(integral_constant&lt;size_t, i&gt;())</code>.
</blockquote>

Modify [**parallel.simd.ctor**] p10 as follows:
<blockquote>
This constructor shall not participate in overload resolution unless <code>simd(gen(integral_constant&lt;size_t, i&gt;()))</code> is well-formed for all <code>i</code>
<del>&#8714; <code>[0, size())</code></del>
<ins>&#x2208; [0, <code>size()</code>)<ins>.
</blockquote>
-->

In [**parallel.simd.reductions**] replace all occurences of "for all <del><code>i</code> &#8714; {<em>j</em> &#8714; &#8469;<sub>0</sub> &#8739; <em>j</em> &lt; <code>M::size()</code> &#8896; <code>mask[</code><em>j</em><code>]</code> }</del>" with
"for all <ins>selected elements <code>i</code></ins>".

US 16 {#us16}
=============

Modify [**parallel.scope**] Paragraph 3 as follows:

<blockquote>
The goal of this Technical Specification is to build widespread existing practice for parallelism in the C++ <ins>programming language</ins> <del>standard algorithms library</del>. It gives advice on extensions to those vendors who wish to provide them.
</blockquote>

CA 3 {#ca3}
===========

Remove the column titled "Doc. No." from [**parallel.general.features**] Table 1.

CA 4 {#ca4}
===========

Modify [**parallel.alg.reductions**] Paragraph 3 as follows:

<blockquote>
Modifications to the accumulator by the application of element access functions accrue as
partial results.
At some point before the algorithm returns, the partial results are combined, two at a time, using the reduction object's combiner operation until a single value remains, which is then assigned back to the live-out object.
[ *Note:*
<del>in</del><ins>In</ins> order to produce useful results, modifications to the accumulator should be limited to commutative operations closely related to the combiner operation.
For example if the combiner is `plus<T>`, incrementing the accumulator would be consistent with the combiner but doubling it or assigning to it would not.
— *end note* ]
</blockquote>

CA 9 {#ca9}
===========

Modify [**parallel.exceptions.synopsis**] p2 as follows:

<blockquote>
<del>The type <code>exception_list::iterator</code> fulfills the requirements of <code>ForwardIterator</code>.</del>
<ins>`exception_list::iterator` is an iterator which meets the forward iterator requirements and has a value type of `exception_ptr`.</ins>
</blockquote>
<!-- This is a copy of the tzdb wording -->

DE 1 {#us1}
===========

Modify the `array`-returning declarations of `split` in [**parallel.simd.synopsis**]:

<blockquote>
<pre><code>
template&lt;size_t... Sizes, class T, class Abi&gt;
  tuple&lt;simd&lt;T, simd_abi::deduce_t&lt;T, Sizes&gt;&gt;...&gt;
    split(const simd&lt;T, Abi&gt;&amp;);
template&lt;size_t... Sizes, class T, class Abi&gt;
  tuple&lt;simd_mask&lt;T, simd_mask_abi::deduce_t&lt;T, Sizes&gt;&gt;...&gt;
    split(const simd_mask&lt;T, Abi&gt;&amp;);
template&lt;class V, class Abi&gt;
  array&lt;V, simd_size_v&lt;typename V::value_type, Abi&gt; / V::size()&gt;
    split(const simd&lt;typename V::value_type, Abi&gt;&amp;);
template&lt;class V, class Abi&gt;
  array&lt;V, simd_size_v&lt;typename V::<ins>simd_type::</ins>value_type, Abi&gt; / V::size()&gt;
    split(const simd_mask&lt;typename V::<ins>simd_type::</ins>value_type, Abi&gt;&amp;);
</code></pre>
</blockquote>

Modify the `array`-returning definitions of `split` in [**parallel.simd.casts**]:

<blockquote>
<pre><code>
template&lt;class V, class Abi&gt;
  array&lt;V, simd_size_v&lt;typename V::value_type, Abi&gt; / V::size()&gt;
    split(const simd&lt;typename V::value_type, Abi&gt;&amp; x);
template&lt;class V, class Abi&gt;
  array&lt;V, simd_size_v&lt;typename V::<ins>simd_type::</ins>value_type, Abi&gt; / V::size()&gt;
    split(const simd_mask&lt;typename V::<ins>simd_type::</ins>value_type, Abi&gt;&amp; x);
</code></pre>

*Returns:* An array of data-parallel objects with the `i`-th `simd`/`simd_mask` element of the `j`-th
element initialized to the value of the element in `x` with index `i + j * V::size()`.

*Remarks:* These functions shall not participate in overload resolution unless
- <code>simd_size_v&lt;typename V::<ins>simd_type::</ins>value_type, Abi&gt;</code> is an integral multiple of `V::size()`, and
- for the overload with a `simd` parameter `is_simd_v<V>` is `true`, <ins>or </ins>for the overload with a `simd_mask` parameter `is_simd_mask_v<V>` is `true`.

*Remarks:* These functions shall not participate in overload resolution unless <ins>either</ins>
- <del>`simd_size_v<typename V::value_type, Abi>` is an integral multiple of `V::size()`, and</del>
- <del>for the overload with a `simd` parameter `is_simd_v<V>` is `true`, for the overload with a `simd_mask` parameter `is_simd_mask_v<V>` is `true`.</del>
- <ins>`is_simd_v<V>` is `true` and `simd_size_v<typename V::value_type, Abi>` is an integral multiple of `V::size()`, or</ins>
- <ins>`is_simd_mask_v<V>` is `true` and `simd_size_v<typename V::simd_type::value_type, Abi>` is an integral multiple of `V::size()`.</ins>
</blockquote>

CH 2 {#ch2}
================

Modify the synopsis for namespace `simd_abi` in [**parallel.simd.abi**] as follows:

<blockquote>
<pre><code>
namespace simd_abi {
  struct scalar {};
  template&lt;int N&gt; struct fixed_size {};
  template&lt;class T&gt; inline constexpr in<ins>t</ins> max_fixed_size = <i>implementation-defined</i>;
  template&lt;class T&gt; using compatible = <i>implementation-defined</i>;
  template&lt;class T&gt; using native = <i>implementation-defined</i>;
}
</code></pre>
</blockquote>

CH 3, 4 {#ch3-4}
================

Modify [**parallel.simd.abi**] Paragraph 9 as follows:

<blockquote>
`compatible<T>` is an implementation-defined alias for an ABI tag.
[ *Note:*
The intent is to use the ABI tag producing the most efficient data-parallel execution for the element type `T` that ensures ABI compatibility between translation units on the target architecture.
— *end note* ]

[ *Example:*
Consider a target architecture supporting the extended ABI tags `__simd128` and `__simd256`, where the `__simd256` type requires an optional ISA extension on said architecture. Also,
the target architecture does not support long double with either ABI tag. The implementation therefore defines <ins>compatible&lt;T&gt; as an alias for</ins>
- <del>`compatible<T>` is an alias for __simd128 for all vectorizable T, except `long double`, and</del>
- <del>`compatible<long double>` as an alias for scalar.</del>
- <ins>`scalar` if `T` is `long double`, and</ins>
- <ins>`__simd128` otherwise.</ins>
— *end example* ]
</blockquote>

US 1, 2 {#us1}
===========

Modify [**parallel.simd.binary**] as follows:

<blockquote>
<xmp>
friend simd operator+(const simd& lhs, const simd& rhs);
friend simd operator-(const simd& lhs, const simd& rhs);
friend simd operator*(const simd& lhs, const simd& rhs);
friend simd operator/(const simd& lhs, const simd& rhs);
friend simd operator%(const simd& lhs, const simd& rhs);
friend simd operator&(const simd& lhs, const simd& rhs);
friend simd operator|(const simd& lhs, const simd& rhs);
friend simd operator^(const simd& lhs, const simd& rhs);
friend simd operator<<(const simd& lhs, const simd& rhs);
friend simd operator>>(const simd& lhs, const simd& rhs);
</xmp>

*Returns:* A `simd` object initialized with the results of <del>the element-wise application of the indicated operator.</del> <ins>applying the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins>

*Throws:* Nothing.

*Remarks:* Each of these operators shall not participate in overload resolution unless the
indicated operator can be applied to objects of type value_type .
</blockquote>

Modify [**parallel.simd.cassign**] as follows:

<blockquote>
<pre><code>
friend simd&amp; operator+=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator-=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator*=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator/=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator%=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator&amp;=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator|=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator^=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator&lt;&lt;=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator&gt;&gt;=(simd&amp; lhs, const simd&amp; rhs);
friend simd&amp; operator&lt;&lt;=(simd&amp; lhs, int <del>n</del><ins>rhs</ins>);
friend simd&amp; operator&gt;&gt;=(simd&amp; lhs, int <del>n</del><ins>rhs</ins>);
</code></pre>

*Effects:* These operators <del>perform the indicated binary element-wise operation.</del> <ins>apply the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins> 

*Returns:* `lhs`.

*Throws:* Nothing.

*Remarks:* These operators shall not participate in overload resolution unless the indicated operator can be applied to objects of type `value_type`.
</blockquote>

Modify [**parallel.simd.comparison**] as follows:

<blockquote>
<code><pre>
friend mask_type operator==(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator!=(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;gt;=(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;lt;=(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;gt;(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
friend mask_type operator&amp;lt;(const simd&amp; <ins>lhs</ins>, const simd&amp; <ins>rhs</ins>);
</pre></code>

*Returns:* A `simd_mask` object initialized with the results of <del>the element-wise application of the indicated operator.</del> <ins>applying the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins> 

*Throws:* Nothing.
</blockquote>

Modify [**parallel.simd.mask.binary**] as follows:

<blockquote>
<code><pre>
friend simd_mask operator&amp;&amp;(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator||(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator&amp; (const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator| (const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator^ (const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
</pre></code>

*Returns:* A `simd_mask` object initialized with the results of the element-wise appliation of the indicated operator.
</blockquote>

Modify [**parallel.simd.mask.cassign**] as follows:

<blockquote>
<xmp>
friend simd_mask& operator&=(simd_mask& lhs, const simd_mask& rhs) noexcept;
friend simd_mask& operator|=(simd_mask& lhs, const simd_mask& rhs) noexcept;
friend simd_mask& operator^=(simd_mask& lhs, const simd_mask& rhs) noexcept;
</xmp>

*Effects:* These operators <del>perform the indicated binary element-wise operation.</del> <ins>apply the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins> 

*Returns:* `lhs`.
</blockquote>

Modify [**parallel.simd.mask.comparison**] as follows:

<blockquote>
<code><pre>
friend simd_mask operator==(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
friend simd_mask operator!=(const simd_mask&amp; <ins>lhs</ins>, const simd_mask&amp; <ins>rhs</ins>) noexcept;
</pre></code>

*Returns:* An object initialized with the results of the <del>element-wise application of the indicated operator.</del> <ins>applying the indicated operator to `lhs` and `rhs` as an element-wise operation.</ins>
</blockquote>

CH 11, CH 12 {#ch11-12}
=======================

Add `noexcept` to the following functions in [**parallel.simd**]:
<ul>
<li>`simd_cast`</li>
<li>`static_simd_cast`</li>
<li>`split`</li>
<li>`concat`</li>
<li>`reduce(const const_where_expression<M, V>& x, plus<> binary_op)`</li>
<li>`reduce(const const_where_expression<M, V>& x, multiplies<> binary_op)`</li>
<li>`reduce(const const_where_expression<M, V>& x, bit_and<> binary_op)`</li>
<li>`reduce(const const_where_expression<M, V>& x, bit_or<> binary_op)`</li>
<li>`reduce(const const_where_expression<M, V>& x, bit_xor<> binary_op)`</li>
<li>`hmin`</li>
<li>`hmax`</li>
<li>all members of `const_where_expression` and `where_expression`</li>
<li>all `simd` constructors, except `simd(const U* mem, Flags f)`</li>
<li>all `simd` member and non-member operators, except `operator[]`</li>
<li>all `reference` member functions</li>
<li>`simd_mask()`</li>
<!-- simd_mask has noexcept correct already -->
</ul>

Remove `noexcept` from  the following functions in [**parallel.simd**]:
<ul>
<li>`find_first_set` (only the non-simd overload)</li>
<li>`find_last_set` (only the non-simd overload)</li>
<li>`clamp` (only in the synopsis)</li>
</ul>

Remove the following paragraphs:
<ul>
<li> [**parallel.simd.whereexpr**] p10</li>
<li> [**parallel.simd.ctor**] p3</li>
<li> [**parallel.simd.unary**] p5, p9, p13, p17, p20, p23, p27, and p30 </li>
<li> [**parallel.simd.binary**] p3 and p7</li>
<li> [**parallel.simd.cassign**] p4</li>
<li> [**parallel.simd.comparison**] p3</li>
<li> [**parallel.simd.reductions**] p12, p15, p19, p23, p26, p29,  p32,  p35</li>
<li> [**parallel.simd.casts**] p4 and p10</li>
</ul>

Modify [**parallel.simd.overview**] p2 as follows:
<blockquote>
Every specialization of <code>simd</code> shall be a complete type. The specialization <code>simd&lt;T, Abi&gt;</code> is supported if <code>T</code> is a vectorizable type and
<ul>
<li>
<code>Abi</code> is <code>simd_abi::scalar</code>, or
</li>

<li>
<code>Abi</code> is <code>simd_abi::fixed_size&lt;N&gt;</code>, with <code>N</code> <del>is</del> constrained as defined in 9.2.1.
</li>
</ul>

If <code>Abi</code> is an extended ABI tag, it is implementation-defined whether <code>simd&lt;T, Abi&gt;</code> is supported.
[ *Note:* The intent is for implementations to decide on the basis of the currently targeted system. — *end note* ]

If <code>simd&lt;T, Abi&gt;</code> is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment. <ins>Otherwise, the following are `true`:
`is_nothrow_move_constructible_v<simd<T, Abi>>`, `is_nothrow_move_assignable_v<simd<T, Abi>>`, and `is_nothrow_default_constructible_v<simd<T, Abi>>`.</ins>
</blockquote>

Modify [**parallel.simd.mask.overview**] p2 as follows:
<blockquote>
Every specialization of <code>simd_mask</code> shall be a complete type. The specialization <code>simd_mask&lt;T, Abi&gt;</code> is supported if <code>T</code> is a vectorizable type and
<ul>
<li>
<code>Abi</code> is <code>simd_abi::scalar</code>, or
</li>
<li>
<code>Abi</code> is <code>simd_abi::fixed_size&lt;N&gt;</code>, with <code>N</code> constrained as defined in (9.2.1).
</li>
</ul>

If <code>Abi</code> is an extended ABI tag, it is implementation-defined whether <code>simd_mask&lt;T, Abi&gt;</code> is supported.
[ *Note:* The intent is for implementations to decide on the basis of the currently targeted system. — *end note* ]

If <code>simd_mask&lt;T, Abi&gt;</code> is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment. <ins>Otherwise, the following are `true`:
`is_nothrow_move_constructible_v<simd_mask<T, Abi>>`, `is_nothrow_move_assignable_v<simd_mask<T, Abi>>`, and `is_nothrow_default_constructible_v<simd_mask<T, Abi>>`.</ins>
</blockquote>

After [**parallel.simd.mask.ctor**] p8 add a new paragraph:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.mask.copy**] p3 and p7 add a new paragraph:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>

After [**parallel.simd.mask.reductions**] p13, p16, and p22 add a new paragraph:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>


<!--
After [**parallel.simd.whereexpr**] p27 add:
<blockquote>
<ins>
  <em>Throws:</em> Nothing.
</ins>
</blockquote>
-->

<!-- after the ctor is noexcept, the following is unnecessary:
Modify [**parallel.simd.ctor**] p11 as follows:
<blockquote>
The calls to <code>gen</code> are unsequenced with respect to each other.
Vectorization-unsafe standard library functions may not be invoked by <code>gen</code> ([algorithms.parallel.exec]).
<ins>An invocation of <code>gen</code> shall not exit via an uncaught exception.</ins>
</blockquote>
-->

CH 13 {#ch13}
=============

Modify [**parallel.simd.overview**] as follows:

<blockquote>
<pre><code>
template&lt;class T, class Abi&gt; class simd {
public:
  using value_type = T;
  using reference = <i>see below</i>;
  using mask_type = simd_mask&lt;T, Abi&gt;<ins>;</ins>
  using abi_type = Abi;

</code></pre>
<!--
  static constexpr size_t size() noexcept;

  simd() = default;

  <i>// implicit conversion constructor</i>
  template&lt;class U&gt; simd(const simd&lt;U, simd_abi::fixed_size&lt;size()&gt;&gt;&amp;);

  <i>// implicit broadcast constructor (see below for constraints)</i>
  template&lt;class U&gt; simd(U&amp;&amp; value);

  <i>// generator constructor (see below for constraints)</i>
  template&lt;class G&gt; explicit simd(G&amp;&amp; gen);

  <i>// load constructor</i>
  template&lt;class U, class Flags&gt; simd(const U* mem, Flags f);

  <i>// 9.3.4, Copy functions</i>
  template&lt;class U, class Flags&gt; copy_from(const U* mem, Flags f);
  template&lt;class U, class Flags&gt; copy_to(U* mem, Flags f);

  <i>// 9.3.5, Subscript operators</i>
  reference operator[](size_t);
  value_type operator[](size_t) const;

  <i>// 9.3.6, Unary operators</i>
  simd&amp; operator++();
  simd operator++(int);
  simd&amp; operator--();
  simd operator--(int);
  mask_type operator!() const;
  simd operator~() const;
  simd operator+() const;
  simd operator-() const;

  <i>// 9.4.1, Binary operators</i>
  friend simd operator+(const simd&amp;, const simd&amp;);
  friend simd operator-(const simd&amp;, const simd&amp;);
  friend simd operator*(const simd&amp;, const simd&amp;);
  friend simd operator/(const simd&amp;, const simd&amp;);
  friend simd operator%(const simd&amp;, const simd&amp;);
  friend simd operator&amp;(const simd&amp;, const simd&amp;);
  friend simd operator|(const simd&amp;, const simd&amp;);
  friend simd operator^(const simd&amp;, const simd&amp;);
  friend simd operator&lt;&lt;(const simd&amp;, const simd&amp;);
  friend simd operator&gt;&gt;(const simd&amp;, const simd&amp;);
  friend simd operator&lt;&lt;(const simd&amp;, int);
  friend simd operator&gt;&gt;(const simd&amp;, int);

  <i>// 9.4.2, Compound assignment</i>
  friend simd&amp; operator+=(simd&amp;, const simd&amp;);
  friend simd&amp; operator-=(simd&amp;, const simd&amp;);
  friend simd&amp; operator*=(simd&amp;, const simd&amp;);
  friend simd&amp; operator/=(simd&amp;, const simd&amp;);
  friend simd&amp; operator%=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&amp;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator|=(simd&amp;, const simd&amp;);
  friend simd&amp; operator^=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&lt;&lt;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&gt;&gt;=(simd&amp;, const simd&amp;);
  friend simd&amp; operator&lt;&lt;=(simd&amp;, int);
  friend simd&amp; operator&gt;&gt;=(simd&amp;, int);

  <i>// 9.4.3, Compare operators</i>
  friend mask_type operator==(const simd&amp;, const simd&amp;);
  friend mask_type operator!=(const simd&amp;, const simd&amp;);
  friend mask_type operator&gt;=(const simd&amp;, const simd&amp;);
  friend mask_type operator&lt;=(const simd&amp;, const simd&amp;);
  friend mask_type operator&gt;(const simd&amp;, const simd&amp;);
  friend mask_type operator&lt;(const simd&amp;, const simd&amp;);
};
-->
</blockquote>

US 13, US 15, CH 14, CH 15 {#us13-15ch14-15}
=============

Modify the definition of `simd`'s `U&&` constructor in [**parallel.simd.ctor**] as follows:

<blockquote>
<xmp>
template<class U> simd(U&&);
</xmp>

*Effects:* Constructs an object with each element initialized to the value of the argument
after conversion to `value_type`.

*Throws:* Any exception thrown while converting the argument to `value_type`.

*Remarks:* Let `From` <ins>denote</ins><del>identify</del> the type `remove_cv_t<remove_reference_t<U>>`. This constructor shall not participate in overload resolution unless:
- `From` is a vectorizable type and every possibly value of `From` can be represented with `value_type`, or
- `From` is not an arithmetic type and is implicitly convertible to `value_type`, or
- `From` is int, or
- From is `unsigned int` and `value_type` is an unsigned integral type.
</blockquote>

Modify the definition of `simd_cast` in [**parallel.simd.casts**] as follows:

<blockquote>
<pre><code>
template&lt;class T, class U, class Abi&gt; <i>see below</i> simd_cast(const simd&lt;U, Abi&gt;&amp; x);
</code></pre>

Let `To` <ins>denote</ins><del>identify</del> `T::value_type` if `is_simd_v<T>` is `true`, or `T` otherwise.

*Returns:* A `simd` object with the `i`<sup>th</sup> element initialized to `static_cast<To>(x[i])` for all `i` &#x2208; [0, `size()`).

*Throws:* Nothing.

*Remarks:* The function shall not participate in overload resolution unless
- every possible value of type `U` can be represented with type `To`, and
- either
    - `is_simd_v<T>` is `false`, or
    - `T::size() == simd<U, Abi>::size()` is `true`.

The return type is
- `T` if `is_simd_v<T>` is `true`<del>, otherwise</del><ins>;</ins>
- <ins>otherwise,&nbsp;</ins>`simd<T, Abi>` <del>is</del><ins>if</ins> `U` is `T`<del>, otherwise</del><ins>;</ins>
- <ins>otherwise,&nbsp;</ins>`simd<T, simd_abi::fixed_size<simd<U, Abi>::size()>>`
</blockquote>

Modify the definition of `static_simd_cast` in [**parallel.simd.casts**] as follows:

<blockquote>
<pre><code>
template&lt;class T, class U, class Abi&gt; <i>see below</i> static_simd_cast(const simd&lt;U, Abi&gt;&amp; x);
</code></pre>

Let `To` <ins>denote</ins><del>identify</del> `T::value_type` if `is_simd_v<T>` is true or `T` otherwise.

*Returns:* A `simd` object with the `i`<sup>th</sup> element initialized to `static_cast<To>(x[i])` for all `i` &#x2208; [0, `size()`).

*Throws:* Nothing.

*Remarks:* The function shall not participate in overload resolution unless either
- `is_simd_v<T>` is `false`, or
- `T::size() == simd<U, Abi>::size()` is `true`.

The return type is
- `T` if `is_simd_v<T>` is `true`<del>, otherwise</del><ins>;</ins>
- <ins>otherwise,&nbsp;</ins>`simd<T, Abi>` if either `U` is `T` or <del>`U` and `T` are integral types that only differ in signedness, otherwise</del> <ins>`make_signed_t<U>` is `make_signed_t<T>`;</ins>
- <ins>otherwise,&nbsp;</ins>`simd<T, simd_abi::fixed_size<simd<U, Abi>::size()>>`.
</blockquote>

US 22 {#us22}
=============

Modify [**parallel.simd.math**] Paragraph 2 as follows:

<blockquote>
Each function overload produced by the above rules applies the indicated <ins>mathematical</ins><del>`<cmath>`</del> function element-wise.
<ins>[ *Note:*</ins>
The results per element are not required to be bitwise equal to the application of the function which is overloaded for the element type.
<ins>— *end note* ]</ins>
</blockquote>

